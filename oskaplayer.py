import copy
import queue

# Description: Performs minimax search on a given board and returns the next best move.
# Arguments: Start state: string list, Color of the player to move next: string, Number of moves to look ahead: int
# Returns: The next best move after looking n steps ahead: string list
def oskaplayer(start, player, moves):
    board = convertBoard(start)                             # convert string into board representation
    children = createTree(board, player, moves)             # generate a tree with the move operators applied 
    for child in children:
        child.score = child.staticBoardEvaluator(player)    # generate the scores for the leaf nodes

    minimax(children, moves)                                # perform minimax search on the leaf nodes
    nextMove = max(board.children)                          # root node will always take the max of it's children
    return nextMove.createStringList()                      # return the string representation of the next best move


# Minimax Search Function
# Description: Performs minimax search
# Arguments: Leaf nodes of the tree: list, Number of moves to look ahead: int
# Returns: None, just propagate the scores up the tree
def minimax(children, moves):
    parents = []
    nextParents = []
    depth = copy.deepcopy(moves)
    depth -= 1

    if depth % 2 == 0:
        turn = 'max'
    else:
        turn = 'min'

    # For the last breadth of children, propagate the leaf nodes up to their parents
    for child in children:
        parent = child.parent
        if parent not in parents:
            if turn == 'min':
                child = min(parent.children)
                parent.score = child.score
            else:
                child = max(parent.children)
                parent.score = child.score
            parents.append(parent)

    # Switch for the next depth up, and perform the propagation for the rest of the tree
    turn = switchTurn(turn)
    for currentDepth in range(depth, 0, -1):
        for current in parents:
            parent = current.parent
            if turn == 'min':
                child = min(parent.children)
                parent.score = evaluateScore(child, parent, currentDepth)
            else:
                child = max(parent.children)
                parent.score = evaluateScore(child, parent, currentDepth)
            nextParents.append(parent)
        parents = nextParents
        nextParents = []
        turn = switchTurn(turn)

# Description: Movegen for homework 4. Performs the same functionality as movegen except it takes in a
# board object and returns a list of board object. Generates a list of all new boards that can be
# generated by one move given a piece color.
# Arguments: Board object, color of the player
# Returns: List of new board objects
def movegen(board, player):
    newStates = board.generateNewStates(player)
    return newStates

# Board Class
# Description: Representation of the board. Contains lists of white pieces and black pieces.
# Also contains n number of each color pieces, number of rows, and the index of the middle row.
class Board:
    def __init__(self, whitePieces, blackPieces, nPieces):
        self.whitePieces = whitePieces                  # list of piece objects, white
        self.blackPieces = blackPieces                  # list of piece objects, black
        self.nPieces = nPieces                          # number of each color pieces
        self.rows = 2 * nPieces - 3                     # total number of rows on the board
        self.middleRow = nPieces - 2                    # index of the middle row
        self.parent = None
        self.children = []
        self.score = None

    # Description: Class comparison for minimax
    def __cmp__(self, other):
        return cmp(self.score == other.score)

    # Description: Overloads '<' operator for board objects
    def __lt__(self, other):
        return self.score < other.score

    # Description: Prints a representation of the tree
    def __str__(self, level=0):
        ret = "\t"*level+repr(self.score)+"\n"
        for child in self.children:
            ret += child.__str__(level+1)
        return ret

    # Description: Prints out a representation of the oska board
    # Arguments: None
    # Returns: None
    def printBoard(self):
        x = 0
        for z in range(self.nPieces, 1, -1):        # print first half of the board
            for y in range(z):
                print(self.getPos((x,y)), end = " ")
            x += 1
            print()
        x = self.middleRow + 1                      # print second half of the board
        for z in range(3, self.nPieces + 1, 1):
            for y in range(z):
                print(self.getPos((x,y)), end=" ")
            x += 1
            print()

    # Description: Creates a list of strings representing the board
    # Arguments: None
    # Returns: String List
    def createStringList(self):
        res = []
        for row in range(self.rows):
            stringRow = ""
            found = False
            for col in range(self.nPieces):
                if self.getPos((row, col)) == 'OUTOFBOUND':
                    break
                for white in self.whitePieces:
                    if white.pos == (row, col):
                        stringRow += white.color
                        found = True
                        break
                for black in self.blackPieces:
                    if black.pos == (row, col):
                        stringRow += black.color
                        found = True
                        break
                if found == True:
                    found = False
                else:
                    stringRow += "-"
            res.append(stringRow)
        return res

    # Description: Compares 2 board objects to see if they are identical
    # Arguments: The board object to compare
    # Returns: Boolean Value
    def equalTo(self, other):
        for white in self.whitePieces:
            matched = False
            for otherWhite in other.whitePieces:
                if white.pos == otherWhite.pos:
                    matched = True
            if matched == False:
                return False

        for black in self.blackPieces:
            matched = False
            for otherBlack in other.blackPieces:
                if black.pos == otherBlack.pos:
                    matched = True
            if matched == False:
                return False
        return True

    # Description: Returns the string of what occupies a position on the board, also checks for bounds
    # Arguments: Coordinate on the board: tuple, int
    # Returns: Color of the piece occupying the board or '-' for an empty tile: String
    def getPos(self, pos):
        # Error bound checks
        if pos[0] < self.middleRow:
            if pos[0] + pos[1] + 1 > self.nPieces:
                return 'OUTOFBOUND'
        else:
            if pos[0] - pos[1] + 3 < self.nPieces:
                return 'OUTOFBOUND'

        if pos[0] < 0 or pos[0] > self.rows - 1 or pos[1] < 0:
            return 'OUTOFBOUND'

        for piece in self.whitePieces:
            if piece.pos == pos:
                return piece.color
        for piece in self.blackPieces:
            if piece.pos == pos:
                return piece.color
        return '-'

    # Description: Returns the piece object that occupies a position on the board
    # Arguments: Coordinate on the board: tuple, int
    # Returns: Piece Object or None or 'OUTOFBOUND'
    def getPiece(self, pos):
        # Error bound checks
        if pos[0] < self.middleRow:
            if pos[0] + pos[1] + 1 > self.nPieces:
                return 'OUTOFBOUND'
        else:
            if pos[0] - pos[1] + 3 < self.nPieces:
                return 'OUTOFBOUND'

        if pos[0] < 0 or pos[0] > self.rows - 1 or pos[1] < 0:
            return 'OUTOFBOUND'

        for piece in self.whitePieces:
            if piece.pos == pos:
                return piece
        for piece in self.blackPieces:
            if piece.pos == pos:
                return piece
        return None

    # Description: Generates a list of new board states by applying operators on each piece of a given color.
    # Arguments: Color of the piece
    # Returns: List of board objects
    def generateNewStates(self, color):
        if self.goalState('w') or self.goalState('b') or self.isDraw():         # if the board is already at a goal state
            newBoard = copy.deepcopy(self)
            newBoard.parent = self
            self.children.append(newBoard)
            newStates = []
            newStates.append(newBoard)
            return newStates

        newStates = []
        if color == 'w':
            for piece in self.whitePieces:
                stateLeft = self.moveLeftDown(piece)
                if stateLeft != None:
                    newStates.append(stateLeft)

                stateRight = self.moveRightDown(piece)
                if stateRight != None:
                    newStates.append(stateRight)
        else:
            for piece in self.blackPieces:
                stateLeft = self.moveLeftUp(piece)
                if stateLeft != None:
                    newStates.append(stateLeft)

                stateRight = self.moveRightUp(piece)
                if stateRight != None:
                    newStates.append(stateRight)

        # if no legal moves can be made, return the same board as a move
        if newStates == []:
            newBoard = copy.deepcopy(self)
            newBoard.parent = self
            self.children.append(newBoard)
            newStates = []
            newStates.append(newBoard)
            return newStates
        else:
            return newStates


    # Description: Applies the move left down operator for white pieces.
    # Arguments: Piece object
    # Returns: New Board Object with the move operator applied
    def moveLeftDown(self, piece):
        x = piece.pos[0]
        y = piece.pos[1]

        if x < self.middleRow:                              # top board above the middle row
            if y != 0:                                      # if pos is not at the first element of it's row                                                          # bottom half of the board + middle row
                diagonal = self.getPos((x + 1, y - 1))
                if diagonal == '-':
                    return self.createNewBoard((x, y), (x + 1, y - 1))
                elif diagonal == 'b':                                  # if there is an enemy, check if you can jump over
                    if x + 1 == self.middleRow:                        # if the next jump will cross the middle row
                        if self.getPos((x + 2, y - 1)) == '-':
                            return self.createNewBoardJump((x, y), (x + 2, y - 1), (x + 1, y - 1))
                    else:
                        if self.getPos((x + 2, y - 2)) == '-':
                            return self.createNewBoardJump((x, y), (x + 2, y - 2), (x + 1, y - 1))
        else:                                               # bottom board at and below middle row
            diagonal = self.getPos((x + 1, y))
            if diagonal == '-':
                return self.createNewBoard((x, y), (x + 1, y))
            elif diagonal == 'b':                           # if there is an enemy, check if you can jump over
                if y == 0:
                    if self.getPos((x + 2, 0)) == '-':      # if the y = 0, then just have y = 0 and not subtract from it
                        return self.createNewBoardJump((x, y), (x + 2, 0), (x + 1, y))
                else:
                    if self.getPos((x + 2, y - 1)) == '-':  # else
                        return self.createNewBoardJump((x, y), (x + 2, y - 1), (x + 1, y))
        return


    # Description: Applies the move right down for white pieces
    # Arguments: Piece Object
    # Returns: New Board Object with the move operator applied
    def moveRightDown(self, piece):
        x = piece.pos[0]
        y = piece.pos[1]
        topRightBound = x + y + 1                   # will eql to n if it's the last element of it's row (upper board)

        if x < self.middleRow:
            if topRightBound != self.nPieces:                   # if the element is NOT the last element of it's row
                diagonal = self.getPos((x + 1, y))
                if diagonal == '-':                             # if the diagonal tile is empty
                    return self.createNewBoard((x, y), (x + 1, y))
                elif diagonal == 'b':                           # if there is an enemy diagonal, check if you can jump
                    if x + 1 == self.middleRow:                 # if the jump will cross the middle row
                        if self.getPos((x + 2, y + 1)) == '-':
                            return self.createNewBoardJump((x, y), (x + 2, y + 1), (x + 1, y))
                    else:
                        if self.getPos((x + 2, y)) == '-':  # if the second jump tile is empty, then the move is valid
                            return self.createNewBoardJump((x, y), (x + 2, y), (x + 1, y))
        else:
            diagonal = self.getPos((x + 1, y + 1))              # middle row and half bottom of the board
            if diagonal == '-':                                 # if the diagonal tile is empty
                return self.createNewBoard((x, y), (x + 1, y + 1))
            elif diagonal == 'b':                               # if the diagonal is an enemy, check if you can jump
                if self.getPos((x + 2, y + 2)) == '-':
                    return self.createNewBoardJump((x, y), (x + 2, y + 2), (x + 1, y + 1))

        return

    # Description: Applies the move left up for black pieces
    # Arguments: Piece Object
    # Returns: New Board Object with the move operator applied
    def moveLeftUp(self, piece):
        x = piece.pos[0]
        y = piece.pos[1]

        if x <= self.middleRow:                      # top half of the board + middle row
            diagonal = self.getPos((x - 1, y))
            if diagonal == '-':
                return self.createNewBoard((x, y), (x - 1, y))
            elif diagonal == 'w':
                if self.getPos((x - 2, y)) == '-':
                    return self.createNewBoardJump((x, y), (x - 2, y), (x - 1, y))
        else:                                       # bottom half of the board
            if y != 0:
                diagonal = self.getPos((x - 1, y - 1))
                if diagonal == '-':
                    return self.createNewBoard((x, y), (x - 1, y - 1))
                elif diagonal == 'w':
                    if x - 1 == self.middleRow:
                        if self.getPos((x - 2, y - 1)) == '-':
                            return self.createNewBoardJump((x, y), (x - 2, y - 1), (x - 1, y - 1))
                    else:
                        if self.getPos((x - 2, y - 2)) == '-':
                            return self.createNewBoardJump((x, y), (x - 2, y - 2), (x - 1, y - 1))
        return

    # Description: Applies the move right up for black pieces
    # Arguments: Piece Object
    # Returns: New Board Object with the move operator applied
    def moveRightUp(self, piece):
        x = piece.pos[0]
        y = piece.pos[1]

        if x <= self.middleRow:                                                 # Top half of the board + middle row
            if x != 0:
                diagonal = self.getPos((x - 1, y + 1))
                if diagonal == '-':                                             # if the diagonal tile is empty
                    return self.createNewBoard((x, y), (x - 1, y + 1))
                elif diagonal == 'w':                                           # if there is an enemy diagonal
                    if self.getPos((x - 2, y + 2)) == '-':
                        return self.createNewBoardJump((x, y), (x - 2, y + 2), (x - 1, y + 1))
        else:                                                                   # Bottom half of the board
            diagonal = self.getPos((x - 1, y))
            if diagonal == '-':                                                 # if the diagonal tile is empty
                return self.createNewBoard((x, y), (x - 1, y))
            elif diagonal == 'w':                                               # if there is an enemy diagonal
                if x - 1 == self.middleRow:         # if the jump crossed the middle row, the math is different
                    if self.getPos((x - 2, y + 1)) == '-':
                        return self.createNewBoardJump((x, y), (x - 2, y + 1), (x - 1, y))
                else:
                    if self.getPos((x - 2, y)) == '-':
                        return self.createNewBoardJump((x, y), (x - 2, y), (x - 1, y))
        return

    # Description: Creates a new board object that applies a move operator and links to the tree structure
    # Arguments: Old position of the piece to move, new position of the piece to move
    # Returns: A new board object
    def createNewBoard(self, oldPos, newPos):
        newBoard = self.copyBoard(oldPos, newPos)
        newBoard.parent = self  # assign parent to self
        self.children.append(newBoard)
        return newBoard

    # Description: Creates a new board object that applies a move operator but also removes an enemy piece, also
    # links to the tree structure
    # Arguments: Old position of the piece to move, new position of the piece to move, position of the piece to remove
    # Returns: A new board object
    def createNewBoardJump(self, oldPos, newPos, removePos):
        newBoard = self.copyBoardRemove(oldPos, newPos, removePos)
        newBoard.parent = self # assign parent to self
        self.children.append(newBoard)
        return newBoard

    # Description: Creates a new board object that moves a piece on the board
    # Arguments: Old pos of the moving piece, new pos of the moving piece
    # Returns: Copy of the board object with a new piece position
    def copyBoard(self, oldPiece, newPiece):
        whitePieces = []
        blackPieces = []
        nPieces = self.nPieces

        for white in self.whitePieces:
            if white.pos == oldPiece:
                whitePieces.append(Piece(white.color, newPiece))
            else:
                whitePieces.append(Piece(white.color, white.pos))
        for black in self.blackPieces:
            if black.pos == oldPiece:
                blackPieces.append(Piece(black.color, newPiece))
            else:
                blackPieces.append(Piece(black.color, black.pos))

        newBoard = Board(whitePieces, blackPieces, self.nPieces)
        return newBoard

    # Description: Creates a new board object that also removes a piece from the board
    # Arguments: Old pos of the moving piece, new pos of the moving piece, the piece to remove
    # Returns: Copy of the board object with a new piece position and one piece removed
    def copyBoardRemove(self, oldPiece, newPiece, removePiece):
        whitePieces = []
        blackPieces = []

        for white in self.whitePieces:
            if white.pos == removePiece:
                pass
            elif white.pos == oldPiece:
                whitePieces.append(Piece(white.color, newPiece))
            else:
                whitePieces.append(Piece(white.color, white.pos))
        for black in self.blackPieces:
            if black.pos == removePiece:
                pass
            elif black.pos == oldPiece:
                blackPieces.append(Piece(black.color, newPiece))
            else:
                blackPieces.append(Piece(black.color, black.pos))

        newBoard = Board(whitePieces, blackPieces, self.nPieces)
        return newBoard


    # Description: Static Board Evaluator. The idea of my static board evaluator is to
    # take to add up the steps for each of the player's pieces to reach the opposite side
    # of the board PLUS the number of enemy pieces that are blocked by the players; pieces
    # i.e the enemy has no choice for that blocked piece to attack one of the player's pieces.
    # Forcing the enemy to attack one of the player's pieces will put the player in a better
    # position to win since the player will need fewer pieces to reach the other end of the
    # board. This value is then subtracted by the enemy's number of steps + blocked pieces.
    # In total, this is the score for a given board.
    #          (player's num of steps to other side of the board + num of blocked enemys)
    #        - (enemy's num of steps to other side of the board + num of blocked players)
    #        = Score
    # Arguments: Color of the player
    # Returns: Score of the board: int
    def staticBoardEvaluator(self, player):
        if player == 'w':
            enemy = 'b'
        else:
            enemy = 'w'

        if self.isDraw():                   # if draw, make the value slightly better than losing
            return -(998)
        elif self.goalState(player):        # Goal value
            return 999
        elif self.goalState(enemy):         # Enemy win value or Loss Value
            return -(999)
        else:
            playerScore = self.piecesToGoal(player) # Add the number of steps to the opposite row
            playerScore += self.blocked(enemy)      # Add the number of blocked enemies

            enemyScore = self.piecesToGoal(enemy)   # Do the same for the enemy
            enemyScore += self.blocked(player)

            return playerScore - enemyScore         # Subtract the player's score with the enemy's


    # Description: Counts the number of pieces to the opposite side of the board and subtracts that
    # value from the max value (number of pieces * rows). Subtracting from this will result in a
    # higher score rather than just counting the number of steps to the other side of the board.
    # Arguments: Color of the player
    # Returns: Value of the number of steps to the end row: int
    def piecesToGoal(self, color):
        max = self.nPieces * self.rows
        stepsToEndRow = 0
        if color == 'w':
            for piece in self.whitePieces:
                stepsToEndRow += (self.rows - 1) - piece.pos[0]
            return (max - stepsToEndRow)
        else:
            for piece in self.blackPieces:
                stepsToEndRow += piece.pos[0]
            return (max - stepsToEndRow)


    # Description: Counts the player's number of pieces that is blocked by it's enemy, forcing the player
    # to attack the enemy.
    # Arguments: Color of the player
    # Returns: Number of blocked pieces of a player
    def blocked(self, color):
        blocked = 0
        # if white count the number of white pieces being blocked and vise versa
        if color == 'w':
            for piece in self.whitePieces:
                if self.oppositeRow(piece):
                    continue

                x = piece.pos[0]
                y = piece.pos[1]
                leftBlocked = False
                rightBlocked = False
                topRightBound = x + y + 1

                # check left down
                if x < self.middleRow:
                    if self.getPos((x + 1, y - 1)) == 'b' or self.getPos((x + 1, y - 1)) == 'OUTOFBOUND':
                        leftBlocked = True
                else:
                    if self.getPos((x + 1, y)) == 'b' or self.getPos((x + 1, y)) == 'OUTOFBOUND':
                        leftBlocked = True
                # check right down
                if x < self.middleRow:
                    if topRightBound != self.nPieces:
                        if self.getPos((x + 1, y)) == 'b' or self.getPos((x + 1, y)) == 'OUTOFBOUND':
                            rightBlocked = True
                else:
                    if self.getPos((x + 1, y + 1)) == 'b' or self.getPos((x + 1, y + 1)) == 'OUTOFBOUND':
                        rightBlocked = True

                if leftBlocked and rightBlocked:
                    blocked += 1
        else:
            for piece in self.blackPieces:
                if self.oppositeRow(piece):
                    continue

                x = piece.pos[0]
                y = piece.pos[1]
                leftBlocked = False
                rightBlocked = False

                # check left up
                if x <= self.middleRow:
                    if self.getPos((x - 1, y)) == 'w' or self.getPos((x - 1, y)) == 'OUTOFBOUND':
                        leftBlocked = True
                else:
                    if self.getPos((x - 1, y - 1)) == 'w' or self.getPos((x - 1, y - 1)) == 'OUTOFBOUND':
                        leftBlocked = True
                # check right up
                if x <= self.middleRow:
                    if self.getPos((x - 1, y + 1)) == 'w' or self.getPos((x - 1, y + 1)) == 'OUTOFBOUND':
                        rightBlocked = True
                else:
                    if self.getPos((x - 1, y)) == '-' or self.getPos((x - 1, y)) == 'OUTOFBOUND':
                        rightBlocked = True

                if leftBlocked and rightBlocked:
                    blocked += 1
        return blocked


    # Description: Checks if a piece is on it's opposite side of the board
    # Arguments: Piece object
    # Returns: Boolean value
    def oppositeRow(self, piece):
        if piece.color == 'w':
            if piece.pos[0] == self.rows - 1:
                return True
        else:
            if piece.pos[0] == 0:
                return True
        return False


    # Descripton: Checks whether a player is at a goal state: if all of their remaining pieces are on
    # the opposite side of the board, if all of their enemys' pieces are gone, if the player has more
    # remaining pieces on the opposite side of the board than the enemy.
    # Arguments: The color of the player
    # Returns: True/False
    def goalState(self, color):
        if color == 'w':
            if len(self.whitePieces) == 0:          # if you lost because you have no more pieces
                return False
            if len(self.blackPieces) == 0:
                return True
            for piece in self.whitePieces:
                if piece.pos[0] != self.rows - 1:   # if one of the white pieces is not on the other side of the board
                    return False

            numOfBlack = 0
            for piece in self.blackPieces:
                if piece.pos[0] == 0:
                    numOfBlack += 1
                else:
                    return True
            if len(self.whitePieces) - numOfBlack > 0:
                return True
            else:
                return False
        else:
            if len(self.blackPieces) == 0:          # if you lost because you have no more pieces
                return False
            if len(self.whitePieces) == 0:
                return True
            for piece in self.blackPieces:
                if piece.pos[0] != 0:               # if one of the black pieces is not on the other side of the board
                    return False

            numOfWhite = 0
            for piece in self.whitePieces:
                if piece.pos[0] == self.rows - 1:
                    numOfWhite += 1
                else:
                    return True
            if len(self.blackPieces) - numOfWhite > 0:
                return True
            else:
                return False
        return True


    # Description: Checks whether the board is a draw
    # Arguments: None
    # Returns: Boolean Value
    def isDraw(self):
        numOfBlack = 0
        for piece in self.blackPieces:          # Count the num of black pieces that are on the other side of the row
            if piece.pos[0] == 0:
                numOfBlack += 1
            else:
                return False

        numOfWhite = 0
        for piece in self.whitePieces:          # Count the num of white pieces that are on the other side of the row
            if piece.pos[0] == self.rows - 1:
                numOfWhite += 1
            else:
                return False

        if numOfBlack == numOfWhite:
            return True
        else:
            return False


# Piece Object
# Descripton: Class representation for every oska piece on the board. Takes in the color of the piece and
# the position of the piece on the board.
class Piece:
    def __init__(self, color, pos):
        self.color = color              # Color of the piece
        self.pos = pos                  # Position of the piece on the board

    # Description: Overloads the == operator to compare piece objects
    def __eq__(self, other):
        if not isinstance(other, Piece):
            return NotImplemented
        return (self.color == other.color and self.pos == other.pos)


# Description: Converts a string into an oska board representation using a board object and
# Arguments: String representation of the board
# Returns: Board Object
def convertBoard(start):
    whitePieces = []
    blackPieces = []
    nPieces = len(start[0])

    for x, row in enumerate(start):
        for y, tile in enumerate(row):
            if tile != '-':
                if tile == 'w':
                    whitePieces.append(Piece(tile, (x, y)))
                elif tile == 'b':
                    blackPieces.append(Piece(tile, (x, y)))

    return Board(whitePieces, blackPieces, nPieces)


# Description: Generates a tree with a depth of 'moves' and applies all operators to each node.
# Arguments: A board class object, the player to move next, the number of moves to look ahead
# Returns: List of all the leaf nodes
def createTree(board, player, moves):
    currentChildren = []
    currentChildren.append(board)
    newChildren = []

    if player == 'w':
        enemy = 'b'
    else:
        enemy = 'w'

    for move in range(moves):
        for child in currentChildren:
            if move % 2 == 0:                               # alternating moves between players
                children = movegen(child, player)
            else:
                children = movegen(child, enemy)
            newChildren += children
        currentChildren = newChildren
        newChildren = []
    return currentChildren                                  # return the leaf nodes


# Description: Evaluates the score for the parent node given the depth and the child. We want to
# subtract the score with the current depth because we want a winning move that comes eariler to
# have a higher score than one that requires more moves to make. In my tree, goal state boards
# that come earlier than depth will just make a copy of itself until it reaches the depth.
# We don't need to prioritize losing moves because the player is losing anyway so you don't
# need to subtract by the depth.
# Arguments: Child Node, Parent Node, Depth
# Returns: Parent Score: int
def evaluateScore(child, parent, depth):
    if child.equalTo(parent) or depth == 1 or child.score <= 0:
        return child.score
    else:
        return child.score - depth

# Description: Switches the depth type from max to min or vice versa
# Arguments: A string defined to either max or min
# Returns: The opposite of that depth type
def switchTurn(turn):
    if turn == 'max':
        turn = 'min'
    else:
        turn = 'max'
    return turn

# Description: Traces a path from a node back to it's parent
# Arguments: A board leaf node
# Returns: The path starting from the parent node to the child
def tracePath(state):
    path = []
    path.append(state)
    while state.parent != None:
        path.append(state.parent)
        state = state.parent
    path = path[::-1]
    return path

# Sources:
# https://stackoverflow.com/questions/20242479/printing-a-tree-data-structure-in-python

# Written by: Dustin Cai
